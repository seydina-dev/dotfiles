#!/bin/sh

# --- Internal Helpers ---

# Cross-platform clipboard copy
_cin() {
    if [ -n "$WAYLAND_DISPLAY" ] && command -v wl-copy >/dev/null 2>&1; then
        wl-copy
    elif [ -n "$DISPLAY" ] && command -v xclip >/dev/null 2>&1; then
        xclip -selection clipboard
    elif command -v termux-clipboard-set >/dev/null 2>&1; then
        termux-clipboard-set
    elif command -v pbcopy >/dev/null 2>&1; then
        pbcopy
    else
        cat
    fi
}

# Cross-platform clipboard paste
_cout() {
    if [ -n "$WAYLAND_DISPLAY" ] && command -v wl-paste >/dev/null 2>&1; then
        wl-paste
    elif [ -n "$DISPLAY" ] && command -v xclip >/dev/null 2>&1; then
        xclip -selection clipboard -o
    elif command -v termux-clipboard-get >/dev/null 2>&1; then
        termux-clipboard-get
    elif command -v pbpaste >/dev/null 2>&1; then
        pbpaste
    fi
}

# --- Functions ---

# Extract magnet link ID
fmag() {
    [ -z "$1" ] && return
    echo "$1" | cut -d "&" -f1 | _cin
}

# Interactive CD with FZF (filtered)
cddd() {
    if ! command -v fzf >/dev/null 2>&1; then
        echo "fzf is not installed."
        return 1
    fi

    local rust_filters=".rustup|.cargo|debug"
    local node_filters="node_modules|.npm"
    local git_filters=".git"
    local cache_filters=".cache"
    local FZF_OPTIONS="--reverse --border --height 40%"

    local target
    target=$(find "$HOME" -maxdepth 4 -type d 2>/dev/null | \
        grep -vE "${cache_filters}|${node_filters}|${rust_filters}|${git_filters}" | \
        fzf $FZF_OPTIONS)

    [ -n "$target" ] && cd "$target" || return
}

# Fast interactive CD using fd and fzf
cdd() {
    if ! command -v fd >/dev/null 2>&1 || ! command -v fzf >/dev/null 2>&1; then
        echo "fd or fzf is not installed."
        return 1
    fi

    local target
    target=$(fd --type d --hidden --exclude .git --max-depth 4 . "$HOME" | fzf --reverse --border --height 40%)
    [ -n "$target" ] && cd "$target" || return
}

# Interactive file opener
open_fzf() {
    if ! command -v fzf >/dev/null 2>&1; then
        echo "fzf is not installed."
        return 1
    fi

    local file
    file=$(find . -maxdepth 3 -type f 2>/dev/null | fzf)
    if [ -n "$file" ]; then
        if command -v xdg-open >/dev/null 2>&1; then
            xdg-open "$file"
        elif command -v open >/dev/null 2>&1; then
            open "$file"
        else
            echo "No opener (xdg-open/open) found."
        fi
    fi
}

# Interactive WiFi selection (Arch/Debian/Fedora with nmcli)
ssid() {
    if ! command -v nmcli >/dev/null 2>&1 || ! command -v fzf >/dev/null 2>&1; then
        echo "nmcli or fzf is not installed."
        return 1
    fi

    nmcli -t -f SSID dev wifi | grep -v '^--' | sort -u | fzf --reverse --prompt="Select WiFi: " | tr -d '\n' | _cin
}

# Git shortcuts
ghc() {
    [ -z "$1" ] || [ -z "$2" ] && echo "Usage: ghc <user> <repo>" && return
    git clone "git@github.com:${1}/${2}.git"
}

glc() {
    [ -z "$1" ] || [ -z "$2" ] && echo "Usage: glc <user> <repo>" && return
    git clone "git@gitlab.com:${1}/${2}.git"
}

git-ssh() {
    local remote_url
    remote_url=$(git remote get-url origin 2>/dev/null)
    if [ -z "$remote_url" ]; then
        echo "Not a git repository or no origin found."
        return 1
    fi

    # Try to detect username from current URL or use global config
    local user="${1:-$(git config user.name)}"
    if [ -z "$user" ]; then
        echo "Usage: git-ssh [username]"
        return 1
    fi

    local repo
    repo=$(basename "$(git rev-parse --show-toplevel 2>/dev/null)")
    git remote set-url origin "git@github.com:${user}/${repo}.git"
    echo "Remote set to: git@github.com:${user}/${repo}.git"
}

# Interactive Multi-Copy
mcopy() {
    if ! command -v fzf >/dev/null 2>&1; then
        echo "fzf is not installed."
        return 1
    fi

    local target_dir="$1"
    [ -z "$target_dir" ] && echo "Usage: mcopy <target_dir>" && return

    local files
    files=$(ls -A | fzf --reverse -m --prompt='Select files to copy: ')
    [ -z "$files" ] && return

    echo "$files" | xargs -I {} cp -rv "{}" "$target_dir"
}

# Interactive Multi-Delete
mdel() {
    if ! command -v fzf >/dev/null 2>&1; then
        echo "fzf is not installed."
        return 1
    fi

    local files
    files=$(ls -A | fzf --reverse -m --prompt='Select files to DELETE: ')
    [ -z "$files" ] && return

    echo "$files"
    read -p "Are you sure you want to delete these files? [y/N] " confirm
    case "$confirm" in
        [Yy]*) echo "$files" | xargs -I {} rm -rf "{}" ;;
        *) echo "Aborted." ;;
    esac
}

# Universal Archive Extractor
ex() {
    if [ -f "$1" ]; then
        case "$1" in
            *.tar.bz2|*.tbz2) tar xjf "$1" ;;
            *.tar.gz|*.tgz)   tar xzf "$1" ;;
            *.bz2)            bunzip2 "$1" ;;
            *.rar)            unrar x "$1" ;;
            *.gz)             gunzip "$1" ;;
            *.tar)            tar xf "$1" ;;
            *.zip)            unzip "$1" ;;
            *.Z)              uncompress "$1" ;;
            *.7z)             7z x "$1" ;;
            *)                echo "'$1' cannot be extracted via ex()" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

ggc() {
    local name email
    read -p "Enter your name: " name
    read -p "Enter your email: " email
    [ -n "$name" ] && git config --global user.name "$name"
    [ -n "$email" ] && git config --global user.email "$email"
}

gco() {
    if ! command -v fzf >/dev/null 2>&1; then
        echo "fzf is not installed."
        return 1
    fi
    local branch
    branch=$(git branch -a 2>/dev/null | grep -v HEAD | sed 's/.* //' | sed 's/remotes\///' | sort -u | fzf --reverse --border --height 40% --prompt="Checkout branch: ")
    [ -z "$branch" ] && return
    git checkout "$branch"
}

gbd() {
    if ! command -v fzf >/dev/null 2>&1; then
        echo "fzf is not installed."
        return 1
    fi
    local branch
    branch=$(git branch 2>/dev/null | grep -v '*' | sed 's/.* //' | fzf --reverse --border --height 40% --prompt="Delete branch: ")
    [ -z "$branch" ] && return
    git branch -d "$branch"
}

glg() {
    if ! command -v fzf >/dev/null 2>&1; then
        echo "fzf is not installed."
        return 1
    fi
    git log --graph --oneline --all --color=always | fzf --reverse --border --height 60% --ansi --prompt="View commit: " --preview 'git show --color=always $(echo {} | sed "s/.* //")'
}

gsh() {
    if ! command -v fzf >/dev/null 2>&1; then
        echo "fzf is not installed."
        return 1
    fi
    local stash
    stash=$(git stash list 2>/dev/null | fzf --reverse --border --height 40% --prompt="Select stash: ")
    [ -z "$stash" ] && return
    local stash_num=$(echo "$stash" | cut -d: -f1 | sed 's/stash@{//' | sed 's/}//')
    echo "$stash" | grep -q "show" && git stash show -p "stash@{$stash_num}" || git stash apply "stash@{$stash_num}"
}

grs() {
    if ! command -v fzf >/dev/null 2>&1; then
        echo "fzf is not installed."
        return 1
    fi
    local file
    file=$(git status --short 2>/dev/null | fzf --reverse --border --height 40% --prompt="Restore file: " --preview 'git diff --color=always $(echo {} | cut -c4-)')
    [ -z "$file" ] && return
    local filepath=$(echo "$file" | cut -c4-)
    git restore "$filepath"
}

ssh-perm() {
    echo "Setting secure permissions for SSH files..."

    # Create .ssh directory if it doesn't exist
    if [ ! -d ~/.ssh ]; then
        mkdir -p ~/.ssh
        echo "Created ~/.ssh directory"
    fi

    # Fix home directory permissions if too open
    if [ -d ~ ]; then
        homedir_perm=$(stat -c "%a" ~)
        if [ "$homedir_perm" -gt 711 ]; then
            echo "Fixing home directory permissions (was $homedir_perm)"
            chmod 700 ~
        fi
    fi

    # Set .ssh directory permissions
    chmod 700 ~/.ssh

    # Fix private keys (all files without .pub extension)
    find ~/.ssh -type f -not -name "*.pub" -exec chmod 600 {} \; 2>/dev/null

    # Fix public keys
    find ~/.ssh -type f -name "*.pub" -exec chmod 644 {} \; 2>/dev/null

    # Fix specific common files
    [ -f ~/.ssh/known_hosts ] && chmod 644 ~/.ssh/known_hosts
    [ -f ~/.ssh/config ] && chmod 644 ~/.ssh/config
    [ -f ~/.ssh/authorized_keys ] && chmod 600 ~/.ssh/authorized_keys

    # Fix any directory inside .ssh (like those used by some tools)
    find ~/.ssh -type d -exec chmod 700 {} \; 2>/dev/null

    echo "SSH permissions secured!"
    echo "Current permissions:"
    ls -la ~/.ssh/
}

android-perm() {
    echo "Setting secure permissions for Android ADB files..."

    # Check if .android directory exists
    if [ ! -d ~/.android ]; then
        echo "~/.android directory not found. Creating it..."
        mkdir -p ~/.android
    fi

    # Set .android directory permissions
    chmod 700 ~/.android

    # Fix adbkey files (private and public)
    [ -f ~/.android/adbkey ] && chmod 600 ~/.android/adbkey
    [ -f ~/.android/adbkey.pub ] && chmod 644 ~/.android/adbkey.pub

    # Fix other common Android files
    [ -f ~/.android/debug.keystore ] && chmod 600 ~/.android/debug.keystore

    # Fix all other files in .android to be secure
    find ~/.android -type f -exec chmod 600 {} \; 2>/dev/null

    # Allow read for certain files that might need it
    [ -f ~/.android/adbkey.pub ] && chmod 644 ~/.android/adbkey.pub
    [ -f ~/.android/repos.cnf ] && chmod 644 ~/.android/repos.cnf 2>/dev/null

    echo "Android ADB permissions secured!"
    echo "Current permissions:"
    ls -la ~/.android/ 2>/dev/null || echo "~/.android directory is empty"
}
